# FROST MPC 部署与威胁模型

## 你真的需要吗？

**说实话，大部分人用不上。** 只有程序化管理上千个地址时才有必要。

| 你的情况                      | 该用什么                   | 为什么                       |
| ----------------------------- | -------------------------- | ---------------------------- |
| 个人资产                      | 硬件钱包（Ledger/Trezor）  | 简单好用，安全性久经考验     |
| 小团队（2-10 人）             | 多签钱包（2-of-3, 3-of-5） | 区块链原生支持，不用搭服务器 |
| **交易所/托管（1000+ 用户）** | **FROST MPC**              | 唯一能做到程序化+门限安全    |

### 什么情况下必须用 FROST MPC

**场景：** 管理 5 万个用户充值地址

**为什么硬件钱包不行：**
- Ledger 根本生成不了 5 万个地址
- 没法自动签名，每次都要手动确认

**为什么普通多签不行：**
- 5 万用户 = 5 万个独立的多签钱包，管不过来
- 备份太复杂（5 万份配置文件）
- 交易体积大（250 vB vs 110 vB），手续费高

**FROST MPC 怎么解决：**
- 每个用户一个口令 = 一个地址
- 备份简单：n 个主种子就够了
- API 直接调用签名，全自动
- 门限安全（m-of-n 容错机制）
- 交易体积小（和单签一样）

**适合谁用：** 交易所、托管钱包、支付服务商、机构 DeFi

---

## 网络架构

### 三层防御体系

```
┌─────────────────────────────────────────────────┐
│ 第三层：地址生成器（端口 9000）                 │
│ - 生成地址（风险低）                             │
│ - 可以对外开放（加上限流就行）                   │
└──────────────┬──────────────────────────────────┘
               │
┌──────────────▼──────────────────────────────────┐
│ 第二层：签名聚合器（端口 8000）                 │
│ - 签交易（风险高）                               │
│ - 只能内网访问，VPN 进来，严格控制权限           │
└──────────────┬──────────────────────────────────┘
               │
┌──────────────▼──────────────────────────────────┐
│ 第一层：签名节点（核心）                        │
│ - 节点 0、节点 1、节点 2、...                   │
│ - 每个节点单独的私有网络                         │
│ - 不能上网，节点之间不通信                       │
│ - 只接受聚合器的请求                             │
└─────────────────────────────────────────────────┘
```

**核心思路：** 签名节点完全隔离，聚合器负责协调。

---

## 备份与恢复

### 要备份什么

**关键（丢了就全没了）：**

1. **主种子** - 每个节点一个（BIP39 24 词助记词）
   ```
   节点 0: [abandon abandon ... art]
   节点 1: [zoo zoo ... wrong]
   ...
   节点 n-1: [verify verify ... castle]
   ```
   存哪：硬件钱包、银行保险箱、Shamir 密钥分片

2. **门限配置**
   ```toml
   max_signers = n   # 总共几个节点（比如 3, 5, 24）
   min_signers = m   # 最少要几个（比如 2, 3, 18）
   ```

3. **用户口令**
   ```
   user_id → passphrase（任意字符串，建议用高熵值）
   12345 → 550e8400-...  # UUID
   67890 → a3f5b9c2...   # hex
   99999 → 3J98t1Wp...   # base58
   ```

### 全挂了怎么恢复

```bash
# 1. 用备份的主种子重新部署 n 个节点
# 2. 把所有密钥重新生成一遍
for passphrase in all_passphrases:
    POST /api/address/generate {"passphrase": "$passphrase"}

# 3. 验证地址和之前的记录一致
# 4. 继续营业
```

**要多久：** 1 万用户大概 1 小时（DKG 很快：每个地址 30-100ms）

**结果：** 地址一模一样、密钥一模一样（确定性生成）

---

## 威胁模型

**以 m-of-n 配置为例（比如 18-of-24）。道理对所有门限配置都适用。**

### 速查表

| 被攻破的东西      | 能生成地址吗 | 能签名吗 | 钱安全吗     | 怎么办         |
| ----------------- | ------------ | -------- | ------------ | -------------- |
| 不到 m 个节点数据 | 不能         | 不能     | ✅ 安全       | 监控就行       |
| 达到 m 个节点数据 | 不能         | 能*      | ⚠️ **危险**   | 赶紧转移资金   |
| 不到 n 个主种子   | 不能         | 不能     | ✅ 安全       | 审计就够了     |
| 全部 n 个主种子   | 能           | 能       | ❌ **完蛋了** | 立刻转移       |
| 地址生成器        | 能           | 不能     | ✅ 安全       | 影响不大       |
| 签名聚合器        | 不能         | 能*      | ⚠️ 看情况     | 取决于口令强度 |

**\* 还需要口令** - 口令够强（UUID）就安全，口令太弱（1,2,3...）就危险

### 关键区别：节点数据 vs 主种子

**节点数据 = RocksDB 里某些特定口令的密钥分片**
- 攻破 ≥m 个节点 → 只能用这些口令签名
- 影响范围有限：只影响数据库里已有的口令

**主种子 = 根密钥**
- 攻破全部 n 个种子 → 能算出任意口令的密钥
- 全面失守：所有过去和未来的密钥都完了

---

## 具体威胁场景

### 1. 少数节点被黑（不到 m 个）

**比如：** 18-of-24 配置里 5 个节点被黑

**后果：** ✅ 没事（需要 18 个才能签名）

**怎么办：** 继续监控，审计一下被黑的节点

---

### 2. 达到门限的节点被黑（≥ m 个）

**比如：** 18-of-24 配置里 18 个以上被黑

**后果：** ⚠️ **很危险**（如果口令也被拿到）

**怎么办看口令强度：**

**口令够强（UUID、256 位随机数）：**
- 黑客猜不出口令 → 不用太急着转移
- 盯紧异常交易就行

**口令太弱（1, 2, 3...这种顺序号）：**
- 黑客能挨个试 → **立刻转移**
- 马上关掉签名聚合器
- 所有钱转到新系统

**现实情况：** 没有密钥轮换功能。必须链上转账。

---

### 3. 部分主种子泄露（不到 n 个）

**比如：** 24 个种子里 20 个泄露了

**后果：** ✅ 还好（DKG 必须要全部种子）

**为什么：** 少任何 1 个种子，算出来的密钥就完全不一样

**怎么办：** 安全审计，不用转移

---

### 4. 全部主种子泄露（n 个全没了）

**后果：** ❌ **彻底完蛋**

**黑客能干嘛：** 算出任意口令的密钥

**怎么办：** 和黑客抢时间，赶在他前面把钱都转走

**怎么预防：**
- 种子存 HSM 或硬件钱包
- 用 Shamir 分片（每个种子拆成 3-of-5）
- 分散在不同地方

---

### 5. 聚合器被黑

**地址生成器被黑：**
- 能生成地址（隐私泄露）
- 不能签交易
- 影响不大

**签名聚合器被黑：**
- 能请求签名（但需要口令）
- 口令能猜就很危险
- 影响很大

---

### 6. 没备份（种子丢了）

**后果：** ⚠️ **钱永远拿不回来了**

**现实：**
- 密钥生成不出来
- 交易签不了
- 钱永远锁死

**怎么预防：**
- 一定要备份主种子
- 每季度测试一次恢复流程
- 多地备份

---

## 口令安全

**系统对口令没要求，任何字符串都行。** 但口令强度是你的第二道防线。

### 推荐用法（高强度）

```python
# ✅ 选一个

uuid.uuid4()                    # 128 位 UUID
secrets.token_hex(32)           # 256 位十六进制
base58.b58encode(secrets.token_bytes(32))  # 256 位 base58
hashlib.sha256(f"{user_id}:{SECRET_SALT}")  # 加盐哈希
```

**强度：** 2^128 到 2^256，黑客根本枚举不过来

### 危险用法（低强度）

```python
# ❌ 生产环境千万别这么干

str(user_id)              # "12345" - 黑客挨个试 1,2,3...
f"user_{user_id}"         # "user_12345" - 还是顺序的
f"wallet-{counter}"       # "wallet-1" - 能猜到
```

**强度：** 顺序的 → 黑客能试遍所有用户

### 为什么重要

如果 ≥m 个节点被黑：

| 口令类型        | 黑客能签名吗     |
| --------------- | ---------------- |
| 高强度（UUID）  | ❌ 不能（猜不到） |
| 低强度（1,2,3） | ✅ 能（挨个试）   |

---

## 运维建议

### 门限怎么配

| 环境     | 配置                 | 容错能力         |
| -------- | -------------------- | ---------------- |
| 开发测试 | 2-of-3               | 1 个节点挂了没事 |
| 生产环境 | 3-of-5 或 5-of-7     | 2-4 个节点       |
| 大企业   | 10-of-15 或 18-of-24 | 5-8 个节点       |

**经验：**
- `m ≤ 2n/3`（拜占庭容错）
- `n - m ≥ 2`（有容错余地还能签名）

### 监控要做什么

- 记录所有签名请求
- 异常模式告警（频率/金额/目标地址）
- 地理位置异常检测

### 应急预案

- 定好什么情况下转移资金
- 提前准备好冷钱包地址
- 写好用户沟通模板

### 测试演练

- 每季度做一次渗透测试
- 每季度演练一次恢复流程（测试种子备份能不能用）

---

## 总结

**什么保护资金安全：**
1. 门限机制（需要 ≥m 个节点才能签）
2. 口令够强（高熵值，别用顺序号）
3. 网络隔离（不能直连节点）
4. 种子备份（全部 n 个都要备）

**致命弱点：**
- 全部 n 个主种子泄露 → 全完了
- ≥m 个节点数据 + 口令数据库泄露 → 被盗

**关键限制：**
- 没有密钥轮换功能（必须链上转账换地址）
- 被黑掉 ≥m 个节点 → 需要紧急转移
- 只能靠多层防御

**灵活性：**
- 任意 m-of-n 配置都行（2-of-3 到 18-of-24+）
- n 越大可用性越高
- m 越大安全性越高（但容错能力越低）
