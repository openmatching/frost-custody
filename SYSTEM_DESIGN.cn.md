# FROST MPC 部署与威胁模型

## 你需要这个吗？

**大多数人不需要。** 只有在程序化管理 1000+ 地址时才需要 FROST MPC。

| 使用场景                        | 解决方案                  | 原因                         |
| ------------------------------- | ------------------------- | ---------------------------- |
| 个人持有                        | 硬件钱包（Ledger/Trezor） | 简单、安全、久经考验         |
| 小团队（2-10 人）               | 多签（2-of-3, 3-of-5）    | 原生区块链支持，无需基础设施 |
| **交易所/托管商（1000+ 用户）** | **FROST MPC**             | 程序化+门限安全的唯一选择    |

### 何时必须使用 FROST MPC

**问题：** 管理 50,000 个用户充值地址

**硬件钱包为什么不行：**
- 无法在 Ledger 上生成 50K 地址
- 无法自动化签名（需要手动确认）

**多签为什么不行：**
- 50K 用户 = 50K 个独立多签钱包
- 备份复杂（50K 个钱包配置）
- 交易体积大（250 vB vs 110 vB）

**FROST MPC 解决方案：**
- 1 个用户口令 = 1 个唯一地址
- 备份：n 个主种子 + 口令数据库
- API 签名（无需手动干预）
- 门限安全（m-of-n 容错）
- 交易体积小（与单签相同）

**适用场景：** 交易所、托管钱包、支付处理商、机构 DeFi

---

## 网络架构

### 三层安全模型

```
┌─────────────────────────────────────────────────┐
│ 第 3 层：地址聚合器（端口 9000）                │
│ - 生成地址（低风险）                             │
│ - 可公开暴露（配合限流）                         │
└──────────────┬──────────────────────────────────┘
               │
┌──────────────▼──────────────────────────────────┐
│ 第 2 层：签名聚合器（端口 8000）                │
│ - 签署交易（高风险）                             │
│ - 仅 VPN/内网，严格访问控制                      │
└──────────────┬──────────────────────────────────┘
               │
┌──────────────▼──────────────────────────────────┐
│ 第 1 层：签名节点（关键）                       │
│ - 节点 0、节点 1、节点 2、...                   │
│ - 每个节点在独立的私有网络中                     │
│ - 无互联网访问，节点间不通信                     │
│ - 仅接受聚合器的入站连接                         │
└─────────────────────────────────────────────────┘
```

**核心原则：** 签名节点完全隔离，聚合器负责编排。

---

## 备份与恢复

### 需要备份什么

**关键（丢失 = 失去一切）：**

1. **主种子** - 每个节点一个（BIP39 24 词助记词）
   ```
   节点 0: [abandon abandon ... art]
   节点 1: [zoo zoo ... wrong]
   ...
   节点 n-1: [verify verify ... castle]
   ```
   存储位置：硬件钱包、纸质保险箱、Shamir 密钥分享

2. **门限配置**
   ```toml
   max_signers = n   # 节点总数（例如 3, 5, 24）
   min_signers = m   # 门限值（例如 2, 3, 18）
   ```

3. **口令数据库**
   ```
   user_id → passphrase（任意字符串，推荐高熵）
   12345 → 550e8400-...  # UUID
   67890 → a3f5b9c2...   # hex
   99999 → 3J98t1Wp...   # base58
   ```
   加密存储，与节点分离

### 恢复（全部基础设施丢失）

```bash
# 1. 用原始主种子部署 n 个节点
# 2. 重新生成所有密钥
for passphrase in all_passphrases:
    POST /api/address/generate {"passphrase": "$passphrase"}

# 3. 验证地址与记录匹配
# 4. 恢复运营
```

**时间：** 10K 用户约 1 小时（DKG 很快：每个地址 30-100ms）

**结果：** 相同地址、相同密钥（确定性重新生成）

---

## 威胁模型

**假设 m-of-n 配置（例如 18-of-24）。原则适用于任何门限。**

### 快速参考

| 被攻破的组件        | 能生成地址？ | 能签名？ | 资金安全？     | 行动             |
| ------------------- | ------------ | -------- | -------------- | ---------------- |
| < m 个节点**数据**  | 否           | 否       | ✅ 安全         | 监控             |
| ≥ m 个节点**数据**  | 否           | 是*      | ⚠️ **危急**     | 立即迁移资金     |
| < n 个**主种子**    | 否           | 否       | ✅ 安全         | 仅审计           |
| 全部 n 个**主种子** | 是           | 是       | ❌ **全部丢失** | 立即迁移         |
| 地址聚合器          | 是           | 否       | ✅ 安全         | 影响小           |
| 签名聚合器          | 否           | 是*      | ⚠️ 高风险       | 取决于口令安全性 |

**\* 需要口令** - 高熵口令（UUID）安全，顺序口令（1,2,3...）危急

### 关键洞察：数据 ≠ 主种子

**节点数据 = RocksDB 中特定口令的份额**
- 攻破 ≥m 个节点 → 可为这些口令签名
- 影响范围有限：仅影响数据库中的口令

**主种子 = 根密钥**
- 攻破全部 n 个种子 → 可重新生成任何口令的密钥
- 全面攻破：影响所有过去和未来的密钥

---

## 威胁场景

### 1. 少数节点被攻破（< m）

**示例：** 18-of-24 配置中 5 个节点被攻破

**影响：** ✅ 安全（需要 18 个才能签名）

**行动：** 监控，审计被攻破的节点

---

### 2. 达到门限的节点被攻破（≥ m）

**示例：** 18-of-24 配置中 18+ 个节点被攻破

**影响：** ⚠️ **危急**（如果口令被攻破）

**行动取决于口令熵值：**

**高熵（UUID、256 位 hex/base58）：**
- 攻击者无法猜测口令 → 计划迁移（不紧急）
- 监控异常活动

**低熵（顺序 ID：1, 2, 3...）：**
- 攻击者可以枚举 → **立即迁移**
- 立即冻结签名聚合器
- 将所有资金转移到新基础设施

**现实：** 不存在密钥轮换。必须在链上迁移资金。

---

### 3. 部分主种子被攻破（< n）

**示例：** 24 个种子中 20 个被攻破

**影响：** ✅ 安全（DKG 需要所有种子）

**原因：** 缺少任何 1 个种子 → 完全不同的密钥

**行动：** 安全审计，无需迁移

---

### 4. 全部主种子被攻破（n/n）

**影响：** ❌ **全面攻破**

**攻击者可以：** 重新生成任何口令的密钥

**行动：** 抢在攻击者之前迁移所有资金

**预防：**
- 将种子存储在 HSM 或硬件钱包中
- 使用 Shamir 密钥分享（每个种子 3-of-5 分割）
- 地理分布存储

---

### 5. 聚合器被攻破

**地址聚合器：**
- 可以生成地址（隐私泄露）
- 无法签署交易
- 影响小

**签名聚合器：**
- 可以请求签名（需要口令）
- 如果口令可猜测则危急
- 影响大

---

### 6. 无备份（种子丢失）

**影响：** ⚠️ **永久资金损失**

**现实：**
- 无法重新生成密钥
- 无法签署交易
- 所有资金永久锁定

**预防：**
- 备份主种子
- 每季度测试恢复
- 多地理位置存储

---

## 口令安全

**系统接受任意字符串作为口令。** 无格式要求。

**但口令熵是你的第二道防线。**

### 推荐（高熵）

```python
# ✅ 使用其中之一

uuid.uuid4()                    # 128 位 UUID
secrets.token_hex(32)           # 256 位 hex
base58.b58encode(secrets.token_bytes(32))  # 256 位 base58
hashlib.sha256(f"{user_id}:{SECRET_SALT}")  # 加盐哈希
```

**安全性：** 2^128 到 2^256 空间 → 无法枚举

### 危险（低熵）

```python
# ❌ 生产环境禁止

str(user_id)              # "12345" - 攻击者尝试 1,2,3...
f"user_{user_id}"         # "user_12345" - 仍然顺序
f"wallet-{counter}"       # "wallet-1" - 可预测
```

**安全性：** 顺序 → 攻击者可以枚举所有用户

### 为什么重要

如果 ≥m 个节点被攻破：

| 口令类型      | 攻击者能签名吗？ |
| ------------- | ---------------- |
| 高熵（UUID）  | ❌ 否（无法猜测） |
| 低熵（1,2,3） | ✅ 是（可枚举）   |

---

## 运营指南

### 门限配置

| 环境     | 配置                 | 容错能力       |
| -------- | -------------------- | -------------- |
| 开发环境 | 2-of-3               | 1 个节点可失败 |
| 生产环境 | 3-of-5 或 5-of-7     | 2-4 个节点     |
| 企业环境 | 10-of-15 或 18-of-24 | 5-8 个节点     |

**规则：**
- `m ≤ 2n/3`（拜占庭容错）
- `n - m ≥ 2`（容错而不失去签名能力）

### 监控

- 记录所有签名请求
- 异常模式告警（频率/金额/目标地址）
- 地理位置异常检测

### 事件响应

- 定义迁移阈值
- 预先批准的冷钱包地址
- 用户沟通模板

### 测试

- 每季度渗透测试
- 每季度恢复演练（测试种子恢复）

---

## 总结

**保护资金安全的要素：**
1. 门限安全（需要 ≥m 个节点）
2. 口令熵（高熵，非顺序）
3. 网络隔离（无直接节点访问）
4. 主种子备份（全部 n 个种子）

**单点故障：**
- 全部 n 个主种子 → 全部丢失
- ≥m 个节点数据 + 口令数据库 → 被盗

**关键限制：**
- 无密钥轮换（必须在链上迁移资金）
- 攻破 ≥m 个节点 → 需要紧急迁移
- 纵深防御是唯一保护

**灵活性：**
- 任意 m-of-n 配置（2-of-3 到 18-of-24+）
- 更大的 n = 更高可用性
- 更大的 m = 更高安全性（更低容错）

